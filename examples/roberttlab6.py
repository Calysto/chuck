# Robert Thorstad# Assignment 6# Setup random and myro modules, and chuckfrom random import *from chuck import *init()wait(0.1)# Setup the notesfreqList = [261.63,277.18,293.66,311.13,329.63,349.23,369.99,392.00,415.30,            440.00,466.16,493.88,523.25,554.37,587.33,622.25,659.26,698.46,            739.99,783.99,830.61,880.00,932.33,987.77,1046.50]# Setup the saxs = Saxophone()s.connect()s.setGain(1.0)s.setFrequency(440.0)freq = 9wait(0.1)# = Setup the struck barb = StruckBar()b.connect()b.setGain(5.0)b.preset(8)# setup the noteDistanceProbs[] listmaxNoteDistance = 14noteDistanceProbs = []x = 0.0for i in range(maxNoteDistance):    a = 2 ** (i+1)    x = (x + 1.0/a)    noteDistanceProbs.append(x)def selectNoteDistance():    ran = randomNumber()    distance = 0 # the distance of the next note in semitones    for i in range(maxNoteDistance):        if ran < noteDistanceProbs[i]:            distance = i+1            break        if i == maxNoteDistance:            distance = i+1 # in the off-chance that the distance value is             break # extremely high, make sure we set something    return distancedef selectFreq(freq, direction):    distance = selectNoteDistance()    ran = randomNumber()    changeDirectionThresh = 0.7    if direction == "down":        if ran < 0.7:             freq = freq - distance        else:            freq = freq + distance            direction = "up"    else:         if ran < 0.7:             freq = freq + distance        else:            freq = freq - distance            direction = "down"    if freq > (len(freqList) - 1):        freq = (len(freqList) - 1)        direction = "down"    if freq < 0:        freq = 0        direction = "up"    returns = [freq, direction]    return returns def selectAccent():    return 1.0 - randomNumber()/1.75def selectDuration():    # We'll steal the noteDistanceProbs list and use this sequence to generate    # the probabilities of different durations    durationProbs = [0.6, 0.85, 0.95, 1.0]    ran = randomNumber()    for i in range(len(durationProbs)):        if ran < durationProbs[i]:            duration = (i+1)            break        duration = 4 ## if for some reason we get here, make sure we assign a duration    return durationdef playSaxImprov():    freq = 9    #setup the sax (for some reason this seems necessary to repeat here - wierd)    s = Saxophone()    s.connect()    s.setGain(1.0)    s.setFrequency(440.0)    wait(0.1)    # setup the direction to weight towards playing initially - adding this consideration makes the music sound better    direction = "up"    # and play    while timeRemaining(60):        s.noteOff(1.0)        # select freq and direction        freqReturns = selectFreq(freq, direction)        freq = freqReturns[0]        direction = freqReturns[1]        #play        s.setGain(selectAccent())        s.setFrequency(freqList[freq])        s.noteOn(1.0)        wait(0.1 * selectDuration())def playStruckBar():    while timeRemaining(60):        b.setFrequency(523.25)        b.strike(1.0)        wait(.4)        b.setFrequency(392.00)        b.setGain(2.0)        b.strike(1.0)        wait(.4)        b.strike(1.0)        wait(.4)        b.strike(1.0)        wait(.4)#playStruckBar()#playSaxImprov(freq)wait(15)doTogether(playStruckBar, playSaxImprov)# Endingwait(1)s.noteOff(1.0)# That's all, folks.            